---
title: "R Notebook"
output:
  html_document:
    df_print: paged
---

## Welcome to Assignemnt 2, Data Exploration

# Instructions:

Beyond simply running the code below, please insert your data files in the data directory such that the single folder from refine.bio containing the metadata TSV and main TSV file are present in the immediate subdirectory. This can be downloaded from google drive, [here!](https://drive.google.com/file/d/1aOnupOgIn-b7rSoGdRflNBvpfQPcR5v5/view?usp=sharing "Download folder to be unzipped as subdirectory of Data!")

Below we've transcribed the assignment instructions with corresponding code blocks beneath each.

```{r}
# Install requisite libraries
library(dplyr)
library(tidyverse)
library(readr)
```

### 1. Download the expression data and matching metadata from Refine.Bio that you selected in Assignment 1.

-   You should have a matrix of samples by genes expression data. If your matrix has Ensembl IDs (e.g. ENSG00000141510) instead of Hugo gene names (e.g. TP53), convert the names following these directions:

    -   alexslemonade.github.io/refinebio-examples/03-rnaseq/gene-id-annotation_rnaseq_01_ensembl.html bioconductor.org/help/course-materials/2019/BSS2019/05_Annotations.html - org.hs.eg.db

-   Load the data into R.

```{r}
# Create the data folder if it doesn't exist
if (!dir.exists("data")) {
  dir.create("data")
}

# Define the file path to the plots directory
plots_dir <- "plots"

# Create the plots folder if it doesn't exist
if (!dir.exists(plots_dir)) {
  dir.create(plots_dir)
}

# Define the file path to the results directory
results_dir <- "results"

# Create the results folder if it doesn't exist
if (!dir.exists(results_dir)) {
  dir.create(results_dir)
}

# Define the file path to the data directory
# Replace with the path of the folder the files will be in
data_dir <- file.path("data", "SRP075377")

# Declare the file path to the gene expression matrix file
# inside directory saved as `data_dir`
# Replace with the path to your dataset file
data_file <- file.path(data_dir, "SRP075377.tsv")

# Declare the file path to the metadata file
# inside the directory saved as `data_dir`
# Replace with the path to your metadata file
metadata_file <- file.path(data_dir, "metadata_SRP075377.tsv")

# Check if the gene expression matrix file is at the path stored in `data_file`
file.exists(data_file)

# Check if the metadata file is at the file path stored in `metadata_file`
file.exists(metadata_file)
```

This next step loads the data and annotation libraries which may take from 30 seconds to 2 minutes.

```{r}
# Install the Zebrafish package
if (!("org.Hs.eg.db" %in% installed.packages())) {
  # Install this package if it isn't installed yet
  BiocManager::install("org.Hs.eg.db", update = FALSE)
}

# Attach the library
library(org.Hs.eg.db)

# We will need this so we can use the pipe: %>%
library(magrittr)

# Read in data and metadata  TSV file
metadata <- readr::read_tsv(metadata_file)
expression_df <- readr::read_tsv(data_file) %>%
  # Tuck away the Gene ID column as row names
  tibble::column_to_rownames("Gene")

#Seemingly like a left-join
# Make the data in the order of the metadata
expression_df <- expression_df %>%
  dplyr::select(metadata$refinebio_accession_code)

# Check if this is in the same order
all.equal(colnames(expression_df), metadata$refinebio_accession_code)

# Bring back the "Gene" column in preparation for mapping
expression_df <- expression_df %>%
  tibble::rownames_to_column("Gene")


# Map Ensembl IDs to their associated Entrez IDs
mapped_list <- mapIds(
  org.Hs.eg.db, # Replace with annotation package for your organism
  keys = expression_df$Gene,
  keytype = "ENSEMBL", # Replace with the type of gene identifiers in your data
  column = "ENTREZID", # The type of gene identifiers you would like to map to
  multiVals = "list"
)
```

```{r}
head(mapped_list) #Amazing.
```

```{r}
# Let's make our list a bit more manageable by turning it into a data frame
mapped_df <- mapped_list %>%
  tibble::enframe(name = "Ensembl", value = "Entrez") %>%
  # enframe() makes a `list` column; we will simplify it with unnest()
  # This will result in one row of our data frame per list item
  tidyr::unnest(cols = Entrez)
```

#### What size is your expression matrix?

```{r}
dim(expression_df)
```

#### How many genes does it include?

a: 43363 ensembl IDs OR 44380 Entrez IDs. 13996 Ensembl's had no ENTREZ IDs, but some mapped to many...

```{r}
summary(as.factor(mapped_df$Entrez), maxsum = 5)
```

```{r}
multi_mapped <- mapped_df %>%
  # Let's count the number of times each Ensembl ID appears in `Ensembl` column
  dplyr::count(Ensembl, name = "entrez_id_count") %>%
  # Arrange by the genes with the highest number of Entrez IDs mapped
  dplyr::arrange(desc(entrez_id_count))

# Let's look at the first 6 rows of our `multi_mapped` object
head(multi_mapped)
```

Looks like some ensemblIDs mapped to as many as 210 Entrez IDs...

#### How much variation do you see in the data? To answer these questions, log-scale the data, calculate per-gene median expression ranges, then make a density plot showing those results.

```{r}
#Log scale the data

logscaleData <- expression_df
logscaleData[, -1] <- log(logscaleData[, -1])
logscaleData$median = apply(logscaleData[, -1], 1, median)

calculate_range <- function(row) {
  max_value <- max(row)
  min_value <- min(row)
  range_value <- max_value - min_value
  return(range_value)
}

# Apply the function to each row of the matrix
logscaleData$row_ranges <- apply(logscaleData[,-1], 1, calculate_range)

```

```{r}
justPlotThis <- dplyr::select(logscaleData, columns="Gene", "median", "row_ranges")
justPlotThis <- justPlotThis %>% 
  dplyr::rename(
    Genes = columns,
    Median = median,
    Range = row_ranges,
    )

plot(density(justPlotThis$Median))
plot(density(justPlotThis$Range))
```

#### Summarize your findings.

The majority of the genes show negative median log-scaled expression, implying a lack of correlation. However, a group can be seen with values near 1-2 on the median log scale. These imply that the genes in this group are those which, relative to other genes gathered from the pancreatic islet cells samples, are being expressed the most. This stands against no particular control, however, and so does not yield any meaningful conclusions of the genes at hand being diabetic, but rather just genes that are expressed more.

The range density plot shows an intriguing bimodal distribution. A large group of genes has a minimal range, whereas the majority of the genes fall close to a range of 3.5 (log scale) in expression between samples. Genes with a low variability across all samples are not interesting since this data set contains both diabetic and control patients.

### 2. Now that you have loaded the expression data into R, generate a PCA plot:

-   If you have counts file(s), follow these DESeq2 directions to generate an expression matrix.
-   Use the DESeq2 function plotPCA() to generate your plot (see here)
-   Color your plot by the 2 groups you identified in assignment 1 (e.g., Diabetic vs Non-Diabetic)
-   Make sure you include a legend and label the axes!
    ```{r}
    # First let's install the requisite libraries.
    if (!("DESeq2" %in% installed.packages())) {
      # Install this package if it isn't installed yet
      BiocManager::install("DESeq2", update = FALSE)
    }
    
    # Attach the DESeq2 library
    library(DESeq2)
    ```
    
    Alright, let's prep the metadata to better select what we need.

    ```{r}

    new_expression_df <- readr::read_tsv(data_file) %>%
      tibble::column_to_rownames("Gene")

    metadata <- metadata %>%
      dplyr::mutate(diabetes = dplyr::case_when(
        stringr::str_detect(refinebio_subject, "non t2d") ~ "reference",
        stringr::str_detect(refinebio_subject, "t2d") ~ "diabetic",
      ))

    #Remove ambiguously-labeled samples from metadata
    culledMeta <- metadata[!(metadata$refinebio_subject=="pancreatic islets"),]

    discardColumns <- metadata[(metadata$refinebio_subject=="pancreatic islets"),]
    discardColumns = as.vector(discardColumns$refinebio_accession_code)
    length(discardColumns)
    #Preserve only columns in expression_df that match one of the accession ids
    culled_expression_df = new_expression_df[,!(names(new_expression_df) %in% discardColumns)]

    # Make mutation_status a factor and set the levels appropriately
    culledMeta <- culledMeta %>%
      dplyr::mutate(
        # Here we define the values our factor variable can have and their order.
        diabetes = factor(diabetes, levels = c("reference", "diabetic"))
      )
    ```
    
    ```{r}
    round_culled_expression_df <- round(culled_expression_df)

    
    ddset <- DESeqDataSetFromMatrix(
      # Here we supply non-normalized count data
      countData = round_culled_expression_df,
      # Supply the `colData` with our metadata data frame
      colData = culledMeta,
      # Supply our diabetes variable to `design`
      design = ~diabetes #Diabetes_status
    )
    
    dds_norm <- vst(ddset)
    
    plotPCA(
      dds_norm,
      intgroup = "diabetes"
    )
    
    pca_results <-
      plotPCA(
        dds_norm,
        intgroup = c("diabetes"),
        returnData = TRUE # This argument tells R to return the PCA values
      )
    
    ```
- PCA Plot Summary



-   If you have 3 or 4 students in your group, also generate either t-SNE or UMAP plot, and summarize the differences and similarities between your two plots.
-   UMAP (example here)
```{r}
library("umap")

gene <- DESeqDataSetFromMatrix(
  countData = round_culled_expression_df, # Counts values for all samples in our rounded dataset
  colData = culledMeta, #  Supply the `colData` with our metadata data frame
  design = ~diabetes #Supply our diabetes variable to `design`
  # Diabetes_status
)
gene_norm <- vst(gene)
normalized_counts <- assay(gene_norm) %>%
  t() # transpose this data so each row is a sample
umap_results <- umap::umap(normalized_counts)
umap_plot_df <- data.frame(umap_results$layout) %>%
  # Turn sample IDs from row names into a column
  tibble::rownames_to_column("refinebio_accession_code") %>%
  # Add the metadata into this data frame. Match by sample IDs
  dplyr::inner_join(metadata, by = "refinebio_accession_code")
umap_plot_df
ggplot(
  umap_plot_df,
  aes(
    x = X1,
    y = X2,
    color = diabetes
  )
) +
  geom_point() # Plot individual points to make a scatterplot
```

-   Save your plot(s) and summarize your findings.

### 3. Perform differential analysis on the samples from your two groups, following the directions below

-   alexslemonade.github.io/refinebio-examples/03-rnaseq/differential-expression_rnaseq_01.html

-   Create a volcano plot of your data, following the directions above

    ```{r include=FALSE}
    if (!("EnhancedVolcano" %in% installed.packages())) {
      # Install this package if it isn't installed yet
      BiocManager::install("EnhancedVolcano", update = FALSE)
    }
    if (!("apeglm" %in% installed.packages())) {
      # Install this package if it isn't installed yet
      BiocManager::install("apeglm", update = FALSE)
    }

    # Attach the ggplot2 library for plotting
    library(ggplot2)

    # We will need this so we can use the pipe: %>%
    library(magrittr)
    ```

    

    Volcano plot time.

    ```{r}

    filtered_expression_df <- culled_expression_df %>%
      dplyr::filter(rowSums(.) >= 4000)

    #This culls roughly 35000 genes that show insignificant expression.

    gene_matrix <- round(filtered_expression_df)
    ddset <- DESeqDataSetFromMatrix(
      # Here we supply non-normalized count data
      countData = gene_matrix,
      # Supply the `colData` with our metadata data frame
      colData = culledMeta,
      # Supply our experimental variable to `design`
      design = ~diabetes
    )
    ```

    ```{r}
    #This WILL take some time. To reduce it down from a minute, use adjust the number on the third line of the above cell. The higher, the more genes filtered out, the shorter DESeq will take but the worse the volcano plot will be.
    deseq_object <- DESeq(ddset)
    ```

    ```{r}
    deseq_results <- results(deseq_object)
    deseq_results <- lfcShrink(
      deseq_object, # The original DESeq2 object after running DESeq()
      coef = 2, # The log fold change coefficient used in DESeq(); the default is 2.
      res = deseq_results # The original DESeq2 results table
    )

    # this is of class DESeqResults -- we want a data frame
    deseq_df <- deseq_results %>%
      # make into data.frame
      as.data.frame() %>%
      # the gene names are row names -- let's make them a column for easy display
      tibble::rownames_to_column("Gene") %>%
      # add a column for significance threshold results
      dplyr::mutate(threshold = padj < 0.05) %>%
      # sort by statistic -- the highest values will be genes with
      # higher expression in RPL10 mutated samples
      dplyr::arrange(dplyr::desc(log2FoldChange))



    volcano_plot <- EnhancedVolcano::EnhancedVolcano(
      deseq_df,
      lab = deseq_df$Gene,
      x = "log2FoldChange",
      y = "padj",
      pCutoff = 0.01 # Loosen the cutoff since we supplied corrected p-values
    )
    # Print out plot here
    volcano_plot
    ```

-   reate a table of differentially expressed genes.

    ```{r}
    deseq_df
    ```

-   Save and summarize your findings.

    ```{r}
    readr::write_tsv(
      deseq_df,
      file.path(
        results_dir,
        "diff_expr_results.tsv" # Replace with a relevant output file name
      )
    )
    ```

It seems a handful of genes have stood out as having significant fold change in bot the positive and negative direction relative to the control. Of the 6827 genes examined, 357 meet the threshold discovered for significant change in differential expression, visualized as north of the grey line towards the bottom of the volcano plot. Some are exceptionally negative / positive, and are labeled for their uniqueness.

### 4. Extract the list of significantly differentially expressed genes, and generate a heatmap using ComplexHeatmap

-   Package reference (<https://jokergoo.github.io/ComplexHeatmap-reference/book/>)

-   Add a side bar colored by sample groupings (cancer vs not, etc.)

-   Extract the list of differentially expressed genes and run enrichment analysis. Each student in your team should run a different method OR ontology (e.g., if there are 4 students on the team, there should be results for 4 applications in your assignment writeup).

-   Choose a method:

    -   topGO
    -   clustProfiler
    -   gProfiler2
    -   GenomicSuperSignature
    -   Choose an ontology (e.g. Disease Ontology, Gene Ontology)

### 5. Run enrichment analysis on your data using your selected method and ontology

### 6. Create a table of the enriched processes found for each method in step 4 (one table per method). Create a table showing statistically significantly enriched terms and any characteristics shared by the method you used (e.g., q-value, p-value, log fold change)

### 7. Write a short summary to go with each plot/table you create. Describe what you did, what parameters you used (if any) and an interesting result from it.

As a team, fill out the team evaluation table below.

### 8. Combine all into a single file and submit on Canvas. Make sure that all your code is added to your GitHub repository.
