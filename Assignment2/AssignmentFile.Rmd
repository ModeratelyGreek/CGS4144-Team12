---
title: "R Notebook"
output:
  pdf_document: default
  html_document:
    df_print: paged
---

## Welcome to Assignemnt 2, Data Exploration

# Instructions:

[Beyond simply running the code below, please insert your data files in the data directory such that the single folder from refine.bio containing the metadata TSV and main TSV file are present in the immediate subdirectory. This can be downloaded from google drive, [here!](https://drive.google.com/file/d/1aOnupOgIn-b7rSoGdRflNBvpfQPcR5v5/view?usp=sharing "Download folder to be unzipped as subdirectory of Data!")]{.underline}

[Below we've transcribed the assignment instructions with corresponding code blocks beneath each.]{.underline}

[ðŸš¨Please note,]{.underline}

-   [underlined writing implies it is from us and not the instructions]{.underline}

-   [numerous code blocks were directly excerpted, adapted, and reused from the provided instructions / guidance. We do not believe this to be plagiarism and hope that in declaring it up front we demonstrate our honest intent. The sources used are found in the instructions (which are transcribed in full on this document), and due to how closely the guidance reflected the tasks of the assignment, we felt it wholly appropriate to directly use the best practices provided directly to us for this purpose.]{.underline}

-   [Task 7: Annotating our tables, has been performed inline, in a more traditional notebook manner. We do not reserve the annotations for step 7 and instead hope to meet the criteria by elaborating on all provided images and tables directly adjacent to each.]{.underline}

```{r}
# Install requisite libraries
library(dplyr)
library(tidyverse)
library(readr)
```

### 1. Download the expression data and matching metadata from Refine.Bio that you selected in Assignment 1.

-   You should have a matrix of samples by genes expression data. If your matrix has Ensembl IDs (e.g. ENSG00000141510) instead of Hugo gene names (e.g. TP53), convert the names following these directions:

    -   alexslemonade.github.io/refinebio-examples/03-rnaseq/gene-id-annotation_rnaseq_01_ensembl.html bioconductor.org/help/course-materials/2019/BSS2019/05_Annotations.html - org.hs.eg.db

-   Load the data into R.

```{r}
# Create the data folder if it doesn't exist
if (!dir.exists("data")) {
  dir.create("data")
}

# Define the file path to the plots directory
plots_dir <- "plots"

# Create the plots folder if it doesn't exist
if (!dir.exists(plots_dir)) {
  dir.create(plots_dir)
}

# Define the file path to the results directory
results_dir <- "results"

# Create the results folder if it doesn't exist
if (!dir.exists(results_dir)) {
  dir.create(results_dir)
}

# Define the file path to the data directory
# Replace with the path of the folder the files will be in
data_dir <- file.path("data", "SRP075377")

# Declare the file path to the gene expression matrix file
# inside directory saved as `data_dir`
# Replace with the path to your dataset file
data_file <- file.path(data_dir, "SRP075377.tsv")

# Declare the file path to the metadata file
# inside the directory saved as `data_dir`
# Replace with the path to your metadata file
metadata_file <- file.path(data_dir, "metadata_SRP075377.tsv")

# Check if the gene expression matrix file is at the path stored in `data_file`
file.exists(data_file)

# Check if the metadata file is at the file path stored in `metadata_file`
file.exists(metadata_file)
```

This next step loads the data and annotation libraries which may take from 30 seconds to 2 minutes.

```{r include=FALSE}
# Install the Zebrafish package
if (!("org.Hs.eg.db" %in% installed.packages())) {
  # Install this package if it isn't installed yet
  BiocManager::install("org.Hs.eg.db", update = FALSE)
}

# Attach the library
library(org.Hs.eg.db)

# We will need this so we can use the pipe: %>%
library(magrittr)

# Read in data and metadata  TSV file
metadata <- readr::read_tsv(metadata_file)
expression_df <- readr::read_tsv(data_file) %>%
  # Tuck away the Gene ID column as row names
  tibble::column_to_rownames("Gene")

#Seemingly like a left-join
# Make the data in the order of the metadata
expression_df <- expression_df %>%
  dplyr::select(metadata$refinebio_accession_code)

# Check if this is in the same order
all.equal(colnames(expression_df), metadata$refinebio_accession_code)

# Bring back the "Gene" column in preparation for mapping
expression_df <- expression_df %>%
  tibble::rownames_to_column("Gene")


# Map Ensembl IDs to their associated Entrez IDs
mapped_list <- mapIds(
  org.Hs.eg.db, # Replace with annotation package for your organism
  keys = expression_df$Gene,
  keytype = "ENSEMBL", # Replace with the type of gene identifiers in your data
  column = "ENTREZID", # The type of gene identifiers you would like to map to
  multiVals = "list"
)
```

```{r}
head(mapped_list) #Amazing.
```

```{r include=FALSE}
# Let's make our list a bit more manageable by turning it into a data frame
mapped_df <- mapped_list %>%
  tibble::enframe(name = "Ensembl", value = "Entrez") %>%
  # enframe() makes a `list` column; we will simplify it with unnest()
  # This will result in one row of our data frame per list item
  tidyr::unnest(cols = Entrez)
```

What size is your expression matrix?

```{r }
dim(expression_df)
```

How many genes does it include?

[43363 ensembl IDs OR 44380 Entrez IDs. 13996 Ensembl's had no ENTREZ IDs, but some mapped to many...]{.underline}

```{r}
summary(as.factor(mapped_df$Entrez), maxsum = 5)
```

```{r}
multi_mapped <- mapped_df %>%
  # Let's count the number of times each Ensembl ID appears in `Ensembl` column
  dplyr::count(Ensembl, name = "entrez_id_count") %>%
  # Arrange by the genes with the highest number of Entrez IDs mapped
  dplyr::arrange(desc(entrez_id_count))

# Let's look at the first 6 rows of our `multi_mapped` object
head(multi_mapped)
```

[Looks like some ensemblIDs mapped to as many as 210 Entrez IDs...]{.underline}

How much variation do you see in the data? To answer these questions, log-scale the data, calculate per-gene median expression ranges, then make a density plot showing those results.

```{r include=FALSE}
#Log scale the data

logscaleData <- expression_df
logscaleData[, -1] <- log(logscaleData[, -1])
logscaleData$median = apply(logscaleData[, -1], 1, median)

calculate_range <- function(row) {
  max_value <- max(row)
  min_value <- min(row)
  range_value <- max_value - min_value
  return(range_value)
}

# Apply the function to each row of the matrix
logscaleData$row_ranges <- apply(logscaleData[,-1], 1, calculate_range)

```

```{r}
justPlotThis <- dplyr::select(logscaleData, columns="Gene", "median", "row_ranges")
justPlotThis <- justPlotThis %>% 
  dplyr::rename(
    Genes = columns,
    Median = median,
    Range = row_ranges,
    )

plot(density(justPlotThis$Median))
```

```{r}
# First let's install the requisite libraries.
    if (!("affy" %in% installed.packages())) {
      # Install this package if it isn't installed yet
      BiocManager::install("affy", update = FALSE)
    }
    
expression_df <- readr::read_tsv(data_file) %>%
  # Tuck away the Gene ID column as row names
  tibble::column_to_rownames("Gene")

library(scales)
library(affy)
myColors <- hue_pal()(4)

plotDensity(log(expression_df+1), col=rep(myColors, each=3),
            lty=c(1:ncol(logscaleData)), xlab='Log(count)',
            main='Expression Density Distribution')
```

#### Summarize your findings.

[The majority of the genes show negative median log-scaled expression, implying a lack of correlation. However, a group can be seen with values near 1-2 on the median log scale. These imply that the genes in this group are those which, relative to other genes gathered from the pancreatic islet cells samples, are being expressed the most. This stands against no particular control, however, and so does not yield any meaningful conclusions of the genes at hand being diabetic, but rather just genes that are expressed more.]{.underline}

```{r}
plot(density(justPlotThis$Range))
```

[The range density plot shows an intriguing bimodal distribution. A large group of genes has a minimal range, whereas the majority of the genes fall close to a range of 3.5 (log scale) in expression between samples. Genes with a low variability across all samples are not interesting since this data set contains both diabetic and control patients.]{.underline}

### 2. Now that you have loaded the expression data into R, generate a PCA plot:

-   If you have counts file(s), follow these DESeq2 directions to generate an expression matrix.
-   Use the DESeq2 function plotPCA() to generate your plot (see here)
-   Color your plot by the 2 groups you identified in assignment 1 (e.g., Diabetic vs Non-Diabetic)
-   Make sure you include a legend and label the axes!

```{r}
# First let's install the requisite libraries.
if (!("DESeq2" %in% installed.packages())) {
  # Install this package if it isn't installed yet
  BiocManager::install("DESeq2", update = FALSE)
}

# Attach the DESeq2 library
library(DESeq2)
```

Alright, let's prep the metadata to better select what we need.

```{r include=FALSE}
new_expression_df <- readr::read_tsv(data_file) %>%
  tibble::column_to_rownames("Gene")

metadata <- metadata %>%
  dplyr::mutate(diabetes = dplyr::case_when(
    stringr::str_detect(refinebio_subject, "non t2d") ~ "reference",
    stringr::str_detect(refinebio_subject, "t2d") ~ "diabetic",
  ))

#Remove ambiguously-labeled samples from metadata
culledMeta <- metadata[!(metadata$refinebio_subject=="pancreatic islets"),]

discardColumns <- metadata[(metadata$refinebio_subject=="pancreatic islets"),]
discardColumns = as.vector(discardColumns$refinebio_accession_code)
length(discardColumns)
#Preserve only columns in expression_df that match one of the accession ids
culled_expression_df = new_expression_df[,!(names(new_expression_df) %in% discardColumns)]

# Make mutation_status a factor and set the levels appropriately
culledMeta <- culledMeta %>%
  dplyr::mutate(
    # Here we define the values our factor variable can have and their order.
    diabetes = factor(diabetes, levels = c("reference", "diabetic"))
  )
```

```{r}
round_culled_expression_df <- round(culled_expression_df)


ddset <- DESeqDataSetFromMatrix(
  # Here we supply non-normalized count data
  countData = round_culled_expression_df,
  # Supply the `colData` with our metadata data frame
  colData = culledMeta,
  # Supply our diabetes variable to `design`
  design = ~diabetes #Diabetes_status
)

dds_norm <- vst(ddset)

plotPCA(
  dds_norm,
  intgroup = "diabetes"
)

pca_results <-
  plotPCA(
    dds_norm,
    intgroup = c("diabetes"),
    returnData = TRUE # This argument tells R to return the PCA values
  )

```

-   PCA Plot Summary

-   If you have 3 or 4 students in your group, also generate either t-SNE or UMAP plot, and summarize the differences and similarities between your two plots.

-   UMAP (example here)

```{r}
library("umap")

gene <- DESeqDataSetFromMatrix(
  countData = round_culled_expression_df, # Counts values for all samples in our rounded dataset
  colData = culledMeta, #  Supply the `colData` with our metadata data frame
  design = ~diabetes #Supply our diabetes variable to `design`
  # Diabetes_status
)
gene_norm <- vst(gene)
normalized_counts <- assay(gene_norm) %>%
  t() # transpose this data so each row is a sample
umap_results <- umap::umap(normalized_counts)
umap_plot_df <- data.frame(umap_results$layout) %>%
  # Turn sample IDs from row names into a column
  tibble::rownames_to_column("refinebio_accession_code") %>%
  # Add the metadata into this data frame. Match by sample IDs
  dplyr::inner_join(metadata, by = "refinebio_accession_code")
umap_plot_df
ggplot(
  umap_plot_df,
  aes(
    x = X1,
    y = X2,
    color = diabetes
  )
) +
  geom_point() # Plot individual points to make a scatterplot
```

-   Save your plot(s) and summarize your findings.

### 3. Perform differential analysis on the samples from your two groups, following the directions below

-   alexslemonade.github.io/refinebio-examples/03-rnaseq/differential-expression_rnaseq_01.html

-   Create a volcano plot of your data, following the directions above

    ```{r include=FALSE}
    if (!("EnhancedVolcano" %in% installed.packages())) {
      # Install this package if it isn't installed yet
      BiocManager::install("EnhancedVolcano", update = FALSE)
    }
    if (!("apeglm" %in% installed.packages())) {
      # Install this package if it isn't installed yet
      BiocManager::install("apeglm", update = FALSE)
    }

    # Attach the ggplot2 library for plotting
    library(ggplot2)

    # We will need this so we can use the pipe: %>%
    library(magrittr)
    ```

    Volcano plot time.

    ```{r include=FALSE}
    filtered_expression_df <- culled_expression_df %>%
      dplyr::filter(rowSums(.) >= 4000)

    #This culls roughly 35000 genes that show insignificant expression.

    gene_matrix <- round(filtered_expression_df)
    ddset <- DESeqDataSetFromMatrix(
      # Here we supply non-normalized count data
      countData = gene_matrix,
      # Supply the `colData` with our metadata data frame
      colData = culledMeta,
      # Supply our experimental variable to `design`
      design = ~diabetes
    )
    ```

    ```{r}
    #This WILL take some time. To reduce it down from a minute, use adjust the number on the third line of the above cell. The higher, the more genes filtered out, the shorter DESeq will take but the worse the volcano plot will be.
    deseq_object <- DESeq(ddset)
    ```

    ```{r include=FALSE}
    deseq_results <- results(deseq_object)
    deseq_results <- lfcShrink(
      deseq_object, # The original DESeq2 object after running DESeq()
      coef = 2, # The log fold change coefficient used in DESeq(); the default is 2.
      res = deseq_results # The original DESeq2 results table
    )

    # this is of class DESeqResults -- we want a data frame
    deseq_df <- deseq_results %>%
      # make into data.frame
      as.data.frame() %>%
      # the gene names are row names -- let's make them a column for easy display
      tibble::rownames_to_column("Gene") %>%
      # add a column for significance threshold results
      dplyr::mutate(threshold = padj < 0.05) %>%
      # sort by statistic
      dplyr::arrange(dplyr::desc(log2FoldChange))

    volcano_plot <- EnhancedVolcano::EnhancedVolcano(
      deseq_df,
      lab = deseq_df$Gene,
      x = "log2FoldChange",
      y = "padj",
      pCutoff = 0.01
    )

    ```

    ```{r}
    # Print out plot here
    volcano_plot
    ```

-   Create a table of differentially expressed genes.

    ```{r}
    deseq_df
    ```

-   Save and summarize your findings.

    ```{r include=FALSE}
    readr::write_tsv(
      deseq_df,
      file.path(
        results_dir,
        "diff_expr_results.tsv" # Replace with a relevant output file name
      )
    )
    ```

[It seems a handful of genes have stood out as having significant fold change in bot the positive and negative direction relative to the control. Of the 6827 genes examined, 357 meet the threshold discovered for significant change in differential expression, visualized as north of the grey line towards the bottom of the volcano plot. Some are exceptionally negative / positive, and are labeled for their uniqueness.]{.underline}

### 4. Extract the list of significantly differentially expressed genes, and generate a heatmap using ComplexHeatmap

-   Package reference (<https://jokergoo.github.io/ComplexHeatmap-reference/book/>)

-   Add a side bar colored by sample groupings (cancer vs not, etc.)

```{r eval=FALSE}
deseq_df_enr<-deseq_df[(deseq_df$threshold==TRUE),]
ht = ComplexHeatmap::Heatmap(deseq_df_enr)

ComplexHeatmap::draw(ht)
```

#### HEATMAP SUMMARY:

Due to a number of limitations and obstacles we encountered over the course of doing task #4, we have not included a heatmap using ComplexHeatmap, although we did generate several test Heatmaps. In terms of data, we faced a performance bottleneck due to the extremely large amount of genes present in our dataset, and so our devices took extremely long periods of time to calculate even basic heat maps. In addition, the premise of seprating genes in the sidebar based on their relationship to diabetic/nondiabetic samples was somewhat confusing because such a binary value is contradictory with the purpose of a heatmap. Several youtube resources guided us towards instead attemmpting to reduce our sample size, but this proved very challenging. Had we more time, we'd attempted the following: - Transpose original data - Left join meta data on Accession Code - Group by refineBio_subject, averaging accross genes within subject groups to achieve mean expressions - Omit all further columns - transpose data back, and plot with X axis of 20 subjects, y axis of 355 most significant genes, and a heatmap of log2fold diff expression.

We provide the original code for our initial, very crude Heatmap, to demonstrate our usage of ComplexHeatmap in this task. We hope that the profoundly large dataset we use and the additional challenges faced in attempting such aggregation will be considered in our failure to produce a meaningful output.

### 5. Run enrichment analysis on your data using your selected method and ontology

Extract the list of deferentially expressed genes and run enrichment analysis.

```{r include=FALSE}
#Extracting differentially expressed genes:
deseq_df_enr <- readr::read_tsv(file.path(results_dir, "diff_expr_results.tsv"))
deseq_df_enr<-deseq_df_enr[(deseq_df_enr$threshold==TRUE),]

readr::write_tsv(
  deseq_df_enr,
  file.path(
    results_dir,
    "diff_expr_results_enr.tsv" # Replace with a relevant output file name
  )
)


```

Each student in your team should run a different method OR ontology (e.g., if there are 4 students on the team, there should be results for 4 applications in your assignment writeup).

-   Choose a method:

    -   gProfiler2

[We have opted to use gprofiler2 to avoid the challenges associated with writing R and manipulating our already conclusive data. All three of us are exploring three different ontologies: Biological pathways (<GO:BP>), Molecular Function (<GO:MF>), and Cellular Components (<GO:CC>). The above code isolates only statistically significant genes which we can then paste into gprofiler/gost. Seeing as part 5 contains no further instructions, see part 6 for corresponding write up.]{.underline}

### 6. Create a table of the enriched processes found for each method in step 4 (one table per method). Create a table showing statistically significantly enriched terms and any characteristics shared by the method you used (e.g., q-value, p-value, log fold change)

![im3](https://cdn.discordapp.com/attachments/1148297410318176256/1156772921298124830/gProfiler_hsapiens_2023-09-28_01-39-56.png)

[The above table was produced using gost, an online tool that attempts to display genes clustered by various ontologies, ontologies being such significance as the molecule to which they contribute, regulatory effects they perform, or relationship with a disease among other categories. Of signficance is cytoplasmic relationship within particularly the <GO:CC> table. We can see a very significant P value here of 1.324x10\^-14, which is seemingly reasonable since diabetes would influence certain metabolic pathways naturally present in the cytoplasm, or so we would assume from the results. Biological quality regulation was also closely tied to the differential expression of our genes, as well as protein binding, this last one falling under molecular function. This is intriguing as it may relate to insulin receptors' capacity to bind free glucose, though it is our understanding that this is a fundamental quality not only of pancreatic islet cells but of all somatic cells participating in metabolism.]{.underline}

### 7. Write a short summary to go with each plot/table you create. Describe what you did, what parameters you used (if any) and an interesting result from it.

## As a team, fill out the team evaluation table below.

![im1](https://cdn.discordapp.com/attachments/1148297410318176256/1156784591059816558/image.png)

![im2](https://cdn.discordapp.com/attachments/1148297410318176256/1156784591059816558/image.png)

### 8. Combine all into a single file and submit on Canvas. Make sure that all your code is added to your GitHub repository.

# âœ…
